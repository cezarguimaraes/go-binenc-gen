// Code generated by "gobinenc embed_blank.go"; DO NOT EDIT.

package main

import (
	"io"
	"unsafe"
)

func (s *Innermost) WriteTo(w io.Writer) (n int, err error) {
	size := 2
	buf := make([]byte, size)
	offset := 0
	buf[offset] = byte(s.Foo)
	offset += 1
	buf[offset] = byte(s.Bar)
	offset += 1
	return w.Write(buf)
}

func (s *Innermost) ReadFrom(r io.Reader) error {
	buf := make([]byte, 8)
	r.Read(buf[:1])
	s.Foo = uint8(buf[0])
	r.Read(buf[:1])
	s.Bar = uint8(buf[0])
	return nil
}

func (s *Inner) WriteTo(w io.Writer) (n int, err error) {
	size := 5
	for _, v := range s.Arr4 {
		size += 2
		size += len(v)
	}
	buf := make([]byte, size)
	offset := 0
	buf[offset] = byte(s.Num)
	offset += 1
	buf[offset] = byte(len(s.Arr4))
	buf[offset+1] = byte(len(s.Arr4) >> 8)
	offset += 2
	for _, v := range s.Arr4 {
		buf[offset] = byte(len(v))
		buf[offset+1] = byte(len(v) >> 8)
		offset += 2
		copy(buf[offset:], v)
		offset += len(v)
	}
	buf[offset] = byte(s.Innermost.Foo)
	offset += 1
	buf[offset] = byte(s.Innermost.Bar)
	offset += 1
	return w.Write(buf)
}

func (s *Inner) ReadFrom(r io.Reader) error {
	buf := make([]byte, 8)
	var size uint16
	var tmp []byte
	m := 0
	c := 64
	strBuf := make([]byte, c)
	r.Read(buf[:1])
	s.Num = uint8(buf[0])
	r.Read(buf[:2])
	size = uint16(buf[0]) | (uint16(buf[1]) << 8)
	s.Arr4 = make([]string, size)
	si := int(size)
	for i := 0; i < si; i++ {
		r.Read(buf[:2])
		size = uint16(buf[0]) | (uint16(buf[1]) << 8)
		if c-m < int(size) {
			c = int(size)
			if c < 2*cap(strBuf) {
				c = 2 * cap(strBuf)
			}
			strBuf = append([]byte(nil), make([]byte, c)...)
			m = 0
		}
		r.Read(strBuf[m : m+int(size)])
		tmp = strBuf[m : m+int(size)]
		s.Arr4[i] = *(*string)(unsafe.Pointer(&tmp))
		m += int(size)
	}
	r.Read(buf[:1])
	s.Innermost.Foo = uint8(buf[0])
	r.Read(buf[:1])
	s.Innermost.Bar = uint8(buf[0])
	return nil
}

func (s *Outer) WriteTo(w io.Writer) (n int, err error) {
	size := 6
	for _, v := range s.Inner.Arr4 {
		size += 2
		size += len(v)
	}
	buf := make([]byte, size)
	offset := 0
	buf[offset] = byte(s.Foo)
	offset += 1
	buf[offset] = byte(s.Inner.Num)
	offset += 1
	buf[offset] = byte(len(s.Inner.Arr4))
	buf[offset+1] = byte(len(s.Inner.Arr4) >> 8)
	offset += 2
	for _, v := range s.Inner.Arr4 {
		buf[offset] = byte(len(v))
		buf[offset+1] = byte(len(v) >> 8)
		offset += 2
		copy(buf[offset:], v)
		offset += len(v)
	}
	buf[offset] = byte(s.Inner.Innermost.Foo)
	offset += 1
	buf[offset] = byte(s.Inner.Innermost.Bar)
	offset += 1
	return w.Write(buf)
}

func (s *Outer) ReadFrom(r io.Reader) error {
	buf := make([]byte, 8)
	var size uint16
	var tmp []byte
	m := 0
	c := 64
	strBuf := make([]byte, c)
	r.Read(buf[:1])
	s.Foo = uint8(buf[0])
	r.Read(buf[:1])
	s.Inner.Num = uint8(buf[0])
	r.Read(buf[:2])
	size = uint16(buf[0]) | (uint16(buf[1]) << 8)
	s.Inner.Arr4 = make([]string, size)
	si := int(size)
	for i := 0; i < si; i++ {
		r.Read(buf[:2])
		size = uint16(buf[0]) | (uint16(buf[1]) << 8)
		if c-m < int(size) {
			c = int(size)
			if c < 2*cap(strBuf) {
				c = 2 * cap(strBuf)
			}
			strBuf = append([]byte(nil), make([]byte, c)...)
			m = 0
		}
		r.Read(strBuf[m : m+int(size)])
		tmp = strBuf[m : m+int(size)]
		s.Inner.Arr4[i] = *(*string)(unsafe.Pointer(&tmp))
		m += int(size)
	}
	r.Read(buf[:1])
	s.Inner.Innermost.Foo = uint8(buf[0])
	r.Read(buf[:1])
	s.Inner.Innermost.Bar = uint8(buf[0])
	return nil
}
